<!doctype html>
<html lang="pt-PT">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PROTO — Calyx-like (UI simplificada + progressão bloqueada)</title>
  <style>
    :root{
      --bg:#070a10;
      --panel:#0b1020f2;
      --panel2:#0b1020cc;
      --line:#1a2a55;
      --line2:#223a72;
      --txt:#d8e6ff;
      --muted:#8aa1c7;
      --good:#6dffb5;
      --warn:#ffd36d;
      --bad:#ff6d8a;

      --ore:#c7b08a;
      --iso:#89c2ff;
      --gold:#ffd36d;
      --sup:#b5ff6d;
      --e:#6dfffb;
      --veh:#d6b5ff;

      --land:#0f1b2e;
      --water:#05070d;
      --tileBorder:#132242;

      --radius: 14px;
      --shadow: 0 10px 30px rgba(0,0,0,.5);
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:
        radial-gradient(1000px 650px at 70% -10%, #13224a55, transparent),
        radial-gradient(800px 550px at 15% 5%, #1a7cff22, transparent),
        linear-gradient(180deg, #05060a, #070a10 35%, #070a10);
      color:var(--txt); font-family:var(--font);
      overflow:hidden;
    }

    /* LAYOUT */
    .hud{
      position:fixed; inset:0;
      display:grid;
      grid-template-columns: 340px 1fr 360px;
      grid-template-rows: 82px 1fr 92px;
      gap:12px;
      padding:12px;
    }

    .topbar{
      grid-column:1/4; grid-row:1/2;
      display:flex; flex-direction:column; gap:8px;
      padding:10px 12px;
      background:linear-gradient(180deg, #0b1020ee, #0b1020aa);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    .topRow{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      min-width:290px;
    }
    .logo{
      width:38px; height:38px; border-radius:12px;
      background:
        radial-gradient(circle at 30% 30%, #6dffb566, transparent 60%),
        radial-gradient(circle at 70% 70%, #89c2ff55, transparent 60%),
        linear-gradient(135deg, #101a33, #0b1020);
      border:1px solid #223a72;
      box-shadow: 0 0 0 2px #0b1020 inset, 0 14px 30px rgba(0,0,0,.55);
      flex:0 0 auto;
    }
    .brand h1{
      margin:0;
      font-size:13px; letter-spacing:.18em; text-transform:uppercase;
      color:#cfe8ff;
    }
    .brand small{
      display:block; margin-top:2px;
      color:var(--muted);
      letter-spacing:.04em;
      font-size:11px;
    }

    .chips{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; align-items:center}
    .chip{
      display:flex; align-items:center; gap:10px;
      padding:8px 10px;
      background:linear-gradient(180deg, #0b1020cc, #070a10aa);
      border:1px solid var(--line);
      border-radius:12px;
      box-shadow: 0 0 0 1px rgba(0,0,0,.25) inset;
      min-width:140px;
    }
    .chip .icon{
      width:18px;height:18px; display:grid; place-items:center;
      border-radius:8px; border:1px solid #20345f;
      background:#0b1020;
      flex:0 0 auto;
    }
    .chip .meta{display:flex; flex-direction:column; line-height:1.05}
    .chip .k{font-size:11px;color:var(--muted); letter-spacing:.08em; text-transform:uppercase}
    .chip .v{font-variant-numeric: tabular-nums; font-weight:800; font-size:13px}
    .chip .d{font-variant-numeric: tabular-nums; font-size:11px; color:var(--muted); margin-top:3px}

    .alerts{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:8px 10px;
      border:1px solid #14264d;
      border-radius:12px;
      background:linear-gradient(180deg, #0a0f1fcc, #070a10aa);
      font-size:12px;
      color:var(--muted);
      overflow:hidden;
      white-space:nowrap;
      text-overflow:ellipsis;
    }
    .alerts b{color:var(--txt)}
    .alerts .leftMsg{overflow:hidden;text-overflow:ellipsis}
    .pill{
      padding:4px 8px;
      border-radius:999px;
      border:1px solid #223a72;
      font-size:11px;
      color:var(--muted);
      flex:0 0 auto;
    }
    .pill.good{border-color:#2d6f55;color:var(--good)}
    .pill.warn{border-color:#7a6a2d;color:var(--warn)}
    .pill.bad{border-color:#7a2d48;color:var(--bad)}

    .panel{
      background:linear-gradient(180deg, #0b1020f0, #0b1020b0);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .panel header{
      padding:12px;
      border-bottom:1px solid #132a55;
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      background:linear-gradient(180deg, #101a33aa, transparent);
    }
    .panel header h2{
      margin:0; font-size:12px;
      letter-spacing:.18em; text-transform:uppercase;
      color:#cfe8ff;
    }
    .panel header .meta{color:var(--muted); font-size:12px}

    .left{grid-column:1/2; grid-row:2/3}
    .right{grid-column:3/4; grid-row:2/3}

    .canvasWrap{
      grid-column:2/3; grid-row:2/3;
      position:relative;
      border-radius: var(--radius);
      overflow:hidden;
      border:1px solid var(--line);
      box-shadow: var(--shadow);
      background: radial-gradient(1000px 800px at 50% 40%, #0e1b3a55, transparent 60%), #05070d;
    }
    canvas{display:block; width:100%; height:100%}

    .bottom{
      grid-column:1/4; grid-row:3/4;
      display:grid;
      grid-template-columns: 1fr 520px;
      gap:12px;
    }
    .statusBar{
      background:linear-gradient(180deg, #0b1020f0, #0b1020b0);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:12px;
      overflow:hidden;
    }
    .row{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      font-size:12px; color:var(--muted);
    }
    .row b{color:var(--txt)}
    .bar{
      height:10px; border-radius:999px;
      background:#0a0f1f;
      border:1px solid #172a55;
      overflow:hidden;
      margin-top:8px;
    }
    .bar > div{height:100%; width:0%}
    .bar .player{background:linear-gradient(90deg, #6dffb5, #89c2ff)}
    .bar .enemy{background:linear-gradient(90deg, #ff6d8a, #ff4d7d)}
    .bar .energy{background:linear-gradient(90deg, #6dfffb, #89c2ff)}
    .bar .supply{background:linear-gradient(90deg, #b5ff6d, #6dffb5)}
    .sep{height:1px;background:#14264d;margin:10px 0}

    /* BUILD LIST */
    .scroll{
      overflow:auto;
      padding:12px;
      min-height:0;
    }
    .groupTitle{
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:#cfe8ff;
      margin:8px 0 8px 0;
      display:flex; align-items:center; justify-content:space-between;
      opacity:.9;
    }
    .groupTitle span{color:var(--muted); font-weight:600; letter-spacing:.04em; text-transform:none}
    .gridBtns{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    button{
      cursor:pointer;
      border:1px solid #223a72;
      background: linear-gradient(180deg, #101a33, #0b1020);
      color:var(--txt);
      padding:10px 10px;
      border-radius:12px;
      font-weight:800;
      letter-spacing:.01em;
      transition: transform .08s ease, border-color .1s ease, filter .12s ease;
      box-shadow: 0 0 0 1px rgba(0,0,0,.25) inset;
      font-size:12px;
      display:flex; gap:10px; align-items:center; justify-content:flex-start;
      min-height:44px;
    }
    button:hover{transform: translateY(-1px); border-color:#3a66c7}
    button:active{transform: translateY(0px) scale(.99)}
    button.selected{
      outline:2px solid rgba(109,255,181,.7);
      box-shadow: 0 0 0 2px rgba(0,0,0,.35) inset, 0 0 24px rgba(109,255,181,.15);
    }
    button[disabled]{
      opacity:.45; cursor:not-allowed; filter:saturate(.6);
    }
    .bIcon{
      width:18px;height:18px; display:grid; place-items:center;
      border-radius:8px; border:1px solid #20345f;
      background:#0b1020;
      flex:0 0 auto;
    }
    .bText{display:flex; flex-direction:column; line-height:1.05}
    .bText .name{font-weight:900;font-size:12px}
    .bText .sub{font-size:11px;color:var(--muted); margin-top:3px}

    .controls{
      display:flex; gap:10px; flex-wrap:wrap;
      padding:12px;
      border-top:1px solid #132a55;
      background:linear-gradient(180deg, #0a1020cc, transparent);
    }
    .controls button{
      justify-content:center;
      min-width:110px;
    }
    .danger{
      border-color:#7a2d48;
      background: linear-gradient(180deg, #2a0f1a, #0b1020);
    }

    /* INFO CARDS (seleção / upgrades) */
    .card{
      border:1px solid #1a2a55;
      border-radius:14px;
      background:linear-gradient(180deg, #0a1020cc, #070a10aa);
      padding:12px;
      margin-bottom:10px;
    }
    .cardTop{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .card h3{
      margin:0;
      font-size:12px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:#cfe8ff;
    }
    .badge{
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid #223a72;
      color:var(--muted);
      white-space:nowrap;
    }
    .badge.good{border-color:#2d6f55;color:var(--good)}
    .badge.warn{border-color:#7a6a2d;color:var(--warn)}
    .badge.bad{border-color:#7a2d48;color:var(--bad)}
    .kv{
      display:flex; justify-content:space-between; gap:12px;
      font-size:12px; color:var(--muted);
      margin-top:8px;
    }
    .kv b{color:var(--txt); font-variant-numeric: tabular-nums}
    .hint{
      color:var(--muted);
      font-size:12px;
      line-height:1.35;
      margin-top:8px;
    }
    .mini{
      font-size:11px; color:var(--muted);
      margin-top:6px;
      line-height:1.25;
    }

    .toast{
      position:absolute;
      left:12px; bottom:12px;
      background:linear-gradient(180deg, #0b1020f0, #0b1020c0);
      border:1px solid #223a72;
      border-radius:12px;
      padding:10px 12px;
      color:var(--txt);
      font-size:12px;
      box-shadow: var(--shadow);
      max-width:min(560px, 88%);
      pointer-events:none;
      opacity:0; transform: translateY(6px);
      transition: opacity .25s ease, transform .25s ease;
      backdrop-filter: blur(10px);
      white-space:pre-wrap;
    }
    .toast.show{opacity:1; transform: translateY(0)}
  </style>
</head>

<body>
  <div class="hud">
    <div class="topbar">
      <div class="topRow">
        <div class="brand">
          <div class="logo"></div>
          <div>
            <h1>PROTO — CALYX-LIKE</h1>
            <small>UI legível • ícones dedicados • progressão bloqueada • números em 5 • bónus em 25%</small>
          </div>
        </div>
        <div class="chips" id="chips"></div>
      </div>
      <div class="alerts">
        <div class="leftMsg" id="alertsText">—</div>
        <div class="pill" id="alertsPill">—</div>
      </div>
    </div>

    <div class="panel left">
      <header>
        <h2>Construir</h2>
        <div class="meta">Clique no mapa • Esc cancela</div>
      </header>

      <div class="scroll" id="buildArea"></div>

      <div class="controls">
        <button id="btnPause">⏸ Pausa</button>
        <button id="btnSpeed">⏩ 1x</button>
        <button class="danger" id="btnRestart">↻ Recomeçar</button>
      </div>
    </div>

    <div class="canvasWrap">
      <canvas id="c"></canvas>
      <div class="toast" id="toast"></div>
    </div>

    <div class="panel right">
      <header>
        <h2>Informação</h2>
        <div class="meta">seleção + upgrades</div>
      </header>
      <div class="scroll" id="infoArea"></div>
    </div>

    <div class="bottom">
      <div class="statusBar">
        <div class="row">
          <span><b>Terreno</b> • Jogador <span id="pPlayer">0</span>% • Inimigo <span id="pEnemy">0</span>%</span>
          <span id="winLose" class="mini">—</span>
        </div>
        <div class="bar"><div class="player" id="barPlayer"></div></div>
        <div class="bar"><div class="enemy" id="barEnemy"></div></div>

        <div class="sep"></div>

        <div class="row">
          <span><b>Energia</b> • Gen <span id="eGen">0</span> • Use <span id="eUse">0</span> • fE <span id="fE">1.00</span></span>
          <span class="mini" id="diffName">Normal</span>
        </div>
        <div class="bar"><div class="energy" id="barEnergy"></div></div>

        <div class="row" style="margin-top:8px">
          <span><b>SUP</b> stock <span id="supStock">0</span> • <b>VEH</b> <span id="vehStock">0</span> (mV <span id="mV">1.00</span>)</span>
          <span class="mini">Biomassa: <span id="activeMins">0</span> min</span>
        </div>
        <div class="bar"><div class="supply" id="barSupply"></div></div>
      </div>

      <div class="panel">
        <header>
          <h2>Ajuda</h2>
          <div class="meta">objetivos</div>
        </header>
        <div class="scroll" style="padding:12px">
          <div class="card">
            <div class="hint">
              • Objetivo: <b>Vitória</b> ≥ <span id="winGoal">75</span>% jogador • <b>Derrota</b> ≥ <span id="loseGoal">35</span>% inimigo.<br/>
              • Tudo exceto HQ sofre <b>degradação por energia</b> (<b>fE</b>).<br/>
              • ISO e SUP: apresentados por <b>minuto</b> para legibilidade (regra do design).
            </div>
          </div>
          <div class="card">
            <div class="hint">
              <b>Progressão (bloqueada):</b><br/>
              • Centro de Infraestrutura desbloqueia: Solar A, Nuclear, Exportação, Refinaria e upgrades de infra.<br/>
              • Centro Militar desbloqueia: Relay e upgrades militares.<br/>
              • Centro de Veículos desbloqueia: Fábrica e upgrades de veículos.
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ============================================================
  // Helpers
  // ============================================================
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const smoothstep = t => t*t*(3-2*t);
  const fmt = (v, d=0) => (Math.round(v * (10**d)) / (10**d)).toFixed(d);
  const dist = (ax, ay, bx, by) => Math.hypot(ax-bx, ay-by);

  // ============================================================
  // Simple deterministic noise
  // ============================================================
  function hash2(x, y, seed){
    let n = x * 374761393 + y * 668265263 + seed * 982451653;
    n = (n ^ (n >> 13)) >>> 0;
    n = (n * 1274126177) >>> 0;
    return ((n ^ (n >> 16)) >>> 0) / 4294967296;
  }
  function valueNoise(x, y, seed){
    const xi = Math.floor(x), yi = Math.floor(y);
    const xf = x - xi, yf = y - yi;
    const v00 = hash2(xi, yi, seed);
    const v10 = hash2(xi+1, yi, seed);
    const v01 = hash2(xi, yi+1, seed);
    const v11 = hash2(xi+1, yi+1, seed);
    const sx = smoothstep(xf), sy = smoothstep(yf);
    const a = lerp(v00, v10, sx);
    const b = lerp(v01, v11, sx);
    return lerp(a, b, sy);
  }
  function fbm(x, y, seed, oct=4, lac=2.0, gain=0.5){
    let amp = 1, freq = 1, sum = 0, norm=0;
    for(let i=0;i<oct;i++){
      sum += amp * valueNoise(x*freq, y*freq, seed + i*97);
      norm += amp;
      amp *= gain; freq *= lac;
    }
    return sum / norm;
  }

  // ============================================================
  // Difficulty presets (per spec)
  // ============================================================
  const DIFFS = {
    Easy:   {name:"Easy",   oreTheta:0.55, isoTheta:0.80, oreStep:0.07, isoStep:0.07, p0:0.10, winP:75, loseP:40},
    Normal: {name:"Normal", oreTheta:0.60, isoTheta:0.84, oreStep:0.07, isoStep:0.07, p0:0.15, winP:75, loseP:35},
    Hard:   {name:"Hard",   oreTheta:0.66, isoTheta:0.90, oreStep:0.07, isoStep:0.07, p0:0.20, winP:80, loseP:35},
  };

  // ============================================================
  // Core config / state
  // ============================================================
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const toastEl = document.getElementById("toast");

  let W=0,H=0, DPR=1;

  const N = 64;
  const TILE = 14;
  const TILE_GAP = 1;
  const seed = 1337;

  let paused = false;
  let speed = 1;
  let dtBase = 0.2;
  let acc = 0;

  let diff = DIFFS.Normal;

  const state = { ORE:120, ISO:0, GOLD:60, SUP:0, E:0, VEH:0 };

  const HQ = { x: Math.floor(N/2), y: Math.floor(N/2), placed:false };

  // Upgrades (0..3)
  const up = {
    L_BR:0, L_ext:0, L_exp_eff:0, L_exp_through:0,
    L_solarB:0, L_solarA:0, L_nuclear:0,
    L_sup_ref:0, L_relay_dmg:0, L_relay_range:0, L_relay_sup:0,
    L_veh_prod:0, L_veh_cost:0
  };

  // Unlock (centers)
  const unlock = { infra:false, mil:false, veh:false };

  const buildings = [];
  let nextId = 1;

  // Enemy
  let enemyActive = false;
  let enemyCountdown = 20;
  let activeSeconds = 0;
  let spreadTick = 0;
  let consolidateTick = 0;
  let gameOver = false;
  let winLoseMsg = "—";

  // UI
  let selected = { x: HQ.x, y: HQ.y };
  let buildMode = null;

  // ============================================================
  // Icons (inline SVG)
  // ============================================================
  const Icons = {
    ore: svg(`<path d="M4 9l4-6 4 6-4 6-4-6z"/><path d="M8 5v8" opacity=".35"/>`),
    iso: svg(`<path d="M8 2c2 2 3 3 3 6s-1 4-3 6c-2-2-3-3-3-6s1-4 3-6z"/><path d="M5 8h6" opacity=".35"/>`),
    gold: svg(`<path d="M3 6h10v8H3z"/><path d="M3 6l5-4 5 4" opacity=".35"/>`),
    sup: svg(`<path d="M3 12h10v2H3z"/><path d="M4 5h8l-1 7H5z"/><path d="M6 3h4v2H6z" opacity=".35"/>`),
    energy: svg(`<path d="M9 2L3 9h4l-1 5 6-7H8l1-5z"/>`),
    veh: svg(`<path d="M4 11l1-5h6l1 5H4z"/><path d="M5 12a1 1 0 102 0 1 1 0 10-2 0zm6 0a1 1 0 102 0 1 1 0 10-2 0z" opacity=".35"/>`),

    hq: svg(`<path d="M3 7l5-4 5 4v7H3z"/><path d="M6 14V9h4v5" opacity=".35"/>`),
    solarB: svg(`<path d="M4 5h8v6H4z"/><path d="M2 12h12" opacity=".35"/><path d="M8 2v2M3 3l1 1M13 3l-1 1" opacity=".35"/>`),
    solarA: svg(`<path d="M3 5h10v7H3z"/><path d="M2 13h12" opacity=".35"/><path d="M8 2v2M3 3l1 1M13 3l-1 1" opacity=".35"/>`),
    nuclear: svg(`<path d="M8 3a5 5 0 105 5H8V3z"/><path d="M8 8l4 4" opacity=".35"/>`),
    oreExt: svg(`<path d="M4 14V8l4-4 4 4v6"/><path d="M6 10h4" opacity=".35"/>`),
    isoExt: svg(`<path d="M4 14V7l4-3 4 3v7"/><path d="M8 4v10" opacity=".35"/>`),
    export: svg(`<path d="M3 12h10v2H3z"/><path d="M8 2v8"/><path d="M5 5l3-3 3 3" opacity=".35"/>`),
    refinery: svg(`<path d="M4 13h8v1H4z"/><path d="M5 3h6l-1 9H6z"/><path d="M7 5h2" opacity=".35"/>`),
    factory: svg(`<path d="M3 14V6l3 2V6l3 2V6l3 2v6H3z"/>`),
    relay: svg(`<path d="M8 3l3 3-3 3-3-3 3-3z"/><path d="M2 13h12" opacity=".35"/>`),
    infra: svg(`<path d="M3 12h10v2H3z"/><path d="M4 12V4h3v8M9 12V6h3v6" opacity=".35"/>`),
    mil: svg(`<path d="M8 2l5 2v4c0 3-2 5-5 6-3-1-5-3-5-6V4l5-2z"/><path d="M8 5v7" opacity=".35"/>`),
    vehCenter: svg(`<path d="M3 10l2-4h6l2 4v4H3v-4z"/><path d="M5 14a1 1 0 102 0 1 1 0 10-2 0zm6 0a1 1 0 102 0 1 1 0 10-2 0z" opacity=".35"/>`)
  };

  function svg(inner){
    return `<svg viewBox="0 0 16 16" width="16" height="16" fill="currentColor" aria-hidden="true">${inner}</svg>`;
  }

  // ============================================================
  // Building definitions + PROGRESSÃO BLOQUEADA
  // - requiresUnlock: "infra"|"mil"|"veh" or null
  // - requires: array of building types that must exist (optional)
  // ============================================================
  const BuildingDefs = {
    HQ: { name:"HQ", icon:Icons.hq, buildTime:0, cost:{ORE:0,GOLD:0,ISO:0}, E_gen:10, E_use:5,
          requiresUnlock:null, requires:[], place:(t)=>t.land },

    SolarB: { name:"Painel Solar (B)", icon:Icons.solarB, buildTime:10, cost:{ORE:60,GOLD:0,ISO:0},
              E_gen:()=> 5*(1+0.25*up.L_solarB), E_use:0,
              requiresUnlock:null, requires:["HQ"], place:(t)=>t.land },

    // BLOQUEADO por InfraCenter
    SolarA: { name:"Painel Solar (A)", icon:Icons.solarA, buildTime:15, cost:{ORE:120,GOLD:60,ISO:10},
              E_gen:()=> 15*(1+0.25*up.L_solarA), E_use:0,
              requiresUnlock:"infra", requires:["HQ"], place:(t)=>t.land },

    // BLOQUEADO por InfraCenter
    Nuclear: { name:"Reator Nuclear", icon:Icons.nuclear, buildTime:30, cost:{ORE:300,GOLD:200,ISO:50},
               E_gen:()=> 60*(1+0.25*up.L_nuclear), E_use:5,
               requiresUnlock:"infra", requires:["HQ"], place:(t)=>t.land },

    OreExtractor: { name:"Extrator de Minério", icon:Icons.oreExt, buildTime:10, cost:{ORE:40,GOLD:0,ISO:0},
                    E_gen:0, E_use:5,
                    requiresUnlock:null, requires:["HQ"], place:(t)=>t.land && t.ORE_rem>0 },

    // BLOQUEADO por InfraCenter (para dar progressão clara)
    IsoExtractor: { name:"Extrator de Isótopos", icon:Icons.isoExt, buildTime:15, cost:{ORE:60,GOLD:40,ISO:0},
                    E_gen:0, E_use:10,
                    requiresUnlock:"infra", requires:["HQ"], place:(t)=>t.land && t.ISO_rem>0 },

    // BLOQUEADO por InfraCenter
    Export: { name:"Centro de Exportação", icon:Icons.export, buildTime:15, cost:{ORE:80,GOLD:40,ISO:0},
              E_gen:0, E_use:10,
              requiresUnlock:"infra", requires:["HQ"], place:(t)=>t.land },

    // BLOQUEADO por InfraCenter
    Refinery: { name:"Refinaria (SUP)", icon:Icons.refinery, buildTime:15, cost:{ORE:80,GOLD:40,ISO:0},
                E_gen:0, E_use:10,
                requiresUnlock:"infra", requires:["HQ"], place:(t)=>t.land },

    // BLOQUEADO por VehicleCenter
    VehicleFactory: { name:"Fábrica de Veículos", icon:Icons.factory, buildTime:20, cost:{ORE:100,GOLD:100,ISO:0},
                      E_gen:0, E_use:15,
                      requiresUnlock:"veh", requires:["HQ"], place:(t)=>t.land },

    // BLOQUEADO por MilitaryCenter
    Relay: { name:"Relay", icon:Icons.relay, buildTime:15, cost:{ORE:60,GOLD:60,ISO:0},
             E_gen:0, E_use:5,
             requiresUnlock:"mil", requires:["HQ"], place:(t)=>t.land },

    // Centros (sempre disponíveis após HQ)
    InfraCenter: { name:"Centro de Infraestrutura", icon:Icons.infra, buildTime:15, cost:{ORE:100,GOLD:50,ISO:0},
                   E_gen:0, E_use:5,
                   requiresUnlock:null, requires:["HQ"], place:(t)=>t.land },

    MilitaryCenter: { name:"Centro Militar", icon:Icons.mil, buildTime:15, cost:{ORE:100,GOLD:50,ISO:0},
                      E_gen:0, E_use:5,
                      requiresUnlock:null, requires:["HQ"], place:(t)=>t.land },

    VehicleCenter: { name:"Centro de Veículos", icon:Icons.vehCenter, buildTime:15, cost:{ORE:100,GOLD:50,ISO:0},
                     E_gen:0, E_use:5,
                     requiresUnlock:null, requires:["HQ"], place:(t)=>t.land },
  };

  // ============================================================
  // Upgrades (locked by centers)
  // ============================================================
  const UpgradeDefs = [
    { key:"L_BR", group:"infra", name:"Build Range",
      desc:()=>`BR = 15 + 5·L (agora: ${15+5*up.L_BR}) • Próx: ${15+5*(up.L_BR+1)}`,
      costs:[{ORE:150,GOLD:100,ISO:10},{ORE:200,GOLD:150,ISO:20},{ORE:250,GOLD:200,ISO:30}] },

    { key:"L_ext", group:"infra", name:"Eficiência de extração",
      desc:()=>`+25% por nível (agora: +${25*up.L_ext}%) • Próx: +${25*(up.L_ext+1)}%`,
      costs:[{ORE:150,GOLD:100,ISO:15},{ORE:200,GOLD:150,ISO:25},{ORE:250,GOLD:200,ISO:35}] },

    { key:"L_exp_eff", group:"infra", name:"Eficiência de exportação",
      desc:()=>`GOLD +25%/nível (agora: +${25*up.L_exp_eff}%) • Próx: +${25*(up.L_exp_eff+1)}%`,
      costs:[{ORE:150,GOLD:150,ISO:15},{ORE:200,GOLD:200,ISO:25},{ORE:250,GOLD:250,ISO:35}] },

    { key:"L_exp_through", group:"infra", name:"Throughput exportação",
      desc:()=>`ORE in +25%/nível (agora: +${25*up.L_exp_through}%) • Próx: +${25*(up.L_exp_through+1)}%`,
      costs:[{ORE:150,GOLD:100,ISO:10},{ORE:200,GOLD:150,ISO:20},{ORE:250,GOLD:200,ISO:30}] },

    { key:"L_solarB", group:"infra", name:"Solar básico",
      desc:()=>`E/painel = 5·(1+0.25·L) (agora: +${25*up.L_solarB}%) • Próx: +${25*(up.L_solarB+1)}%`,
      costs:[{ORE:100,GOLD:50,ISO:10},{ORE:150,GOLD:100,ISO:20},{ORE:200,GOLD:150,ISO:30}] },

    { key:"L_solarA", group:"infra", name:"Solar avançado",
      desc:()=>`E/painel = 15·(1+0.25·L) (agora: +${25*up.L_solarA}%) • Próx: +${25*(up.L_solarA+1)}%`,
      costs:[{ORE:150,GOLD:100,ISO:20},{ORE:200,GOLD:150,ISO:30},{ORE:250,GOLD:200,ISO:40}] },

    { key:"L_nuclear", group:"infra", name:"Nuclear",
      desc:()=>`E = 60·(1+0.25·L) (agora: +${25*up.L_nuclear}%) • Próx: +${25*(up.L_nuclear+1)}%`,
      costs:[{ORE:250,GOLD:200,ISO:50},{ORE:300,GOLD:250,ISO:75},{ORE:350,GOLD:300,ISO:100}] },

    { key:"L_sup_ref", group:"mil", name:"Refino de suprimentos",
      desc:()=>`SUP +25%/nível (agora: +${25*up.L_sup_ref}%) • Próx: +${25*(up.L_sup_ref+1)}%`,
      costs:[{ORE:150,GOLD:100,ISO:15},{ORE:200,GOLD:150,ISO:25},{ORE:250,GOLD:200,ISO:35}] },

    { key:"L_relay_dmg", group:"mil", name:"Dano do relay",
      desc:()=>`Dano +25%/nível (agora: +${25*up.L_relay_dmg}%) • Próx: +${25*(up.L_relay_dmg+1)}%`,
      costs:[{ORE:150,GOLD:100,ISO:20},{ORE:200,GOLD:150,ISO:30},{ORE:250,GOLD:200,ISO:40}] },

    { key:"L_relay_range", group:"mil", name:"Raio do relay",
      desc:()=>`R = 10·(1+0.25·L) (agora: ${fmt(10*(1+0.25*up.L_relay_range),1)}) • Próx: ${fmt(10*(1+0.25*(up.L_relay_range+1)),1)}`,
      costs:[{ORE:150,GOLD:100,ISO:20},{ORE:200,GOLD:150,ISO:30},{ORE:250,GOLD:200,ISO:40}] },

    { key:"L_relay_sup", group:"mil", name:"Supressão do relay",
      desc:()=>`Propagação -25%/nível (agora: -${25*up.L_relay_sup}%) • Próx: -${25*(up.L_relay_sup+1)}%`,
      costs:[{ORE:150,GOLD:100,ISO:20},{ORE:200,GOLD:150,ISO:30},{ORE:250,GOLD:200,ISO:40}] },

    { key:"L_veh_prod", group:"veh", name:"Produção de veículos",
      desc:()=>`Tempo = 30·(1-0.25·L) (agora: ${fmt(Math.max(7.5,30*(1-0.25*up.L_veh_prod)),1)}s) • Próx: ${fmt(Math.max(7.5,30*(1-0.25*(up.L_veh_prod+1))),1)}s`,
      costs:[{ORE:150,GOLD:150,ISO:20},{ORE:200,GOLD:200,ISO:30},{ORE:250,GOLD:250,ISO:40}] },

    { key:"L_veh_cost", group:"veh", name:"Logística de veículos",
      desc:()=>`Custos -25%/nível (agora: -${25*up.L_veh_cost}%) • Próx: -${25*(up.L_veh_cost+1)}%`,
      costs:[{ORE:150,GOLD:150,ISO:20},{ORE:200,GOLD:200,ISO:30},{ORE:250,GOLD:250,ISO:40}] },
  ];

  // ============================================================
  // Map + tiles
  // ============================================================
  const grid = [];
  function makeTile(x,y){
    return { x,y, land:false, water:true,
      ORE_rem:0, ISO_rem:0,
      enemy:false, hp:0,
      player:false,
      buildingId:0,
      build:null
    };
  }
  function tileAt(x,y){ return grid[y]?.[x]; }

  function infectTile(tile, init=false){
    tile.enemy = true;
    const L_time = enemyActive ? Math.floor((activeSeconds/60)/2) : 0;
    const hpMax = 25 + 5*L_time;
    tile.hp = init ? hpMax : Math.min(hpMax, Math.max(tile.hp, hpMax*0.6));
    tile.player = false;
  }

  function genMap(){
    grid.length=0;
    for(let y=0;y<N;y++){
      const row=[];
      for(let x=0;x<N;x++) row.push(makeTile(x,y));
      grid.push(row);
    }

    // Island (per spec)
    const cx=N/2, cy=N/2;
    const s=0.08, k=0.45, T=0.92;
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const d = Math.hypot(x-cx, y-cy)/(N/2);
        const n = fbm(x*s, y*s, seed, 4,2,0.5);
        const F = d + k*(1-n);
        const t = grid[y][x];
        t.land = (F<=T);
        t.water = !t.land;
      }
    }
    // ensure center land
    for(let ry=-2; ry<=2; ry++){
      for(let rx=-2; rx<=2; rx++){
        const xx=clamp(HQ.x+rx,0,N-1), yy=clamp(HQ.y+ry,0,N-1);
        grid[yy][xx].land=true; grid[yy][xx].water=false;
      }
    }

    // Resources (clusters)
    const sOre=0.18, sIso=0.28;
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const t=grid[y][x];
        if(!t.land) continue;

        const nOre=fbm(x*sOre,y*sOre,seed+11,3,2.1,0.55);
        const nIso=fbm(x*sIso,y*sIso,seed+29,3,2.0,0.5);

        if(nOre>=diff.oreTheta){
          const q=clamp(Math.floor((nOre-diff.oreTheta)/diff.oreStep),0,4);
          t.ORE_rem=50+25*q;
        }
        if(nIso>=diff.isoTheta){
          const q=clamp(Math.floor((nIso-diff.isoTheta)/diff.isoStep),0,3);
          t.ISO_rem=5+5*q;
        }
      }
    }

    // Enemy initial at edges
    const spots=10;
    for(let i=0;i<spots;i++){
      const edge=Math.floor(Math.random()*4);
      let x,y;
      if(edge===0){x=Math.floor(Math.random()*N);y=0;}
      if(edge===1){x=N-1;y=Math.floor(Math.random()*N);}
      if(edge===2){x=Math.floor(Math.random()*N);y=N-1;}
      if(edge===3){x=0;y=Math.floor(Math.random()*N);}
      for(let t=0;t<40;t++){
        const tile=grid[y][x];
        if(tile.land){
          infectTile(tile,true);
          for(let j=0;j<8;j++){
            const nx=clamp(x+(Math.floor(Math.random()*5)-2),0,N-1);
            const ny=clamp(y+(Math.floor(Math.random()*5)-2),0,N-1);
            if(grid[ny][nx].land) infectTile(grid[ny][nx],true);
          }
          break;
        }
        x=clamp(x+Math.sign(cx-x),0,N-1);
        y=clamp(y+Math.sign(cy-y),0,N-1);
      }
    }

    placeHQ();
  }

  function placeHQ(){
    buildings.length=0; nextId=1;
    for(let y=0;y<N;y++)for(let x=0;x<N;x++){
      const t=grid[y][x];
      t.buildingId=0; t.build=null; t.player=false;
    }

    HQ.placed=true;
    const t=tileAt(HQ.x,HQ.y);
    t.player=true;

    const id=nextId++;
    buildings.push({ id, type:"HQ", x:HQ.x, y:HQ.y, vehProg:0, isoBuffer:0 });
    t.buildingId=id;

    enemyActive=false; enemyCountdown=20; activeSeconds=0;
    spreadTick=0; consolidateTick=0;
    gameOver=false; winLoseMsg="—";

    state.ORE=120; state.ISO=0; state.GOLD=60; state.SUP=0; state.VEH=0;
    for(const k in up) up[k]=0;
    unlock.infra=unlock.mil=unlock.veh=false;

    buildMode=null;
    setSelected(HQ.x,HQ.y);
    toast("HQ estabelecida. Energia líquida inicial: 5. Inimigo ativa em 20s.");
    refreshUI();
  }

  // ============================================================
  // Rules (per spec)
  // ============================================================
  function BR(){ return 15 + 5*up.L_BR; }

  function B_ext(){ return 0.25*up.L_ext; }
  function B_exp_eff(){ return 0.25*up.L_exp_eff; }
  function B_exp_through(){ return 0.25*up.L_exp_through; }
  function B_sup_ref(){ return 0.25*up.L_sup_ref; }
  function B_relay_dmg(){ return 0.25*up.L_relay_dmg; }
  function B_relay_range(){ return 0.25*up.L_relay_range; }
  function B_relay_sup(){ return 0.25*up.L_relay_sup; }
  function B_veh_prod(){ return 0.25*up.L_veh_prod; }
  function B_veh_cost(){ return 0.25*up.L_veh_cost; }

  function mV(){
    const b = 0.25 * Math.floor(state.VEH/5);
    return 1 + Math.min(2.0, b);
  }

  function energyTotals(){
    let E_gen=0, E_use=0;
    for(const b of buildings){
      const t=tileAt(b.x,b.y);
      if(t.build) continue;
      const def=BuildingDefs[b.type];
      const gen=(typeof def.E_gen==="function")?def.E_gen():def.E_gen;
      const use=(typeof def.E_use==="function")?def.E_use():def.E_use;
      E_gen += gen; E_use += use;
    }
    return {E_gen,E_use};
  }
  function fE(){
    const {E_gen,E_use}=energyTotals();
    if(E_use<=0) return 1;
    return Math.min(1, E_gen/E_use);
  }

  // ============================================================
  // Build placement + gating
  // ============================================================
  function withinBuildRange(x,y){ return dist(x,y,HQ.x,HQ.y) <= BR(); }

  function hasBuilding(type){
    return buildings.some(b => b.type===type && !tileAt(b.x,b.y).build);
  }

  function canAfford(cost){
    return state.ORE >= (cost.ORE||0) && state.GOLD >= (cost.GOLD||0) && state.ISO >= (cost.ISO||0);
  }
  function pay(cost){
    state.ORE -= (cost.ORE||0);
    state.GOLD -= (cost.GOLD||0);
    state.ISO -= (cost.ISO||0);
  }

  function costText(cost){
    const parts=[];
    if(cost.ORE) parts.push(`${cost.ORE} ORE`);
    if(cost.GOLD) parts.push(`${cost.GOLD} GOLD`);
    if(cost.ISO) parts.push(`${cost.ISO} ISO`);
    return parts.join(" • ") || "0";
  }

  function gateReason(type){
    const def=BuildingDefs[type];
    if(!HQ.placed) return "Precisa HQ.";
    for(const req of (def.requires||[])){
      if(req==="HQ" && !hasBuilding("HQ")) return "Precisa HQ.";
      if(req!=="HQ" && !hasBuilding(req)) return `Precisa ${BuildingDefs[req]?.name || req}.`;
    }
    if(def.requiresUnlock==="infra" && !unlock.infra) return "Bloqueado: Centro de Infraestrutura.";
    if(def.requiresUnlock==="mil" && !unlock.mil) return "Bloqueado: Centro Militar.";
    if(def.requiresUnlock==="veh" && !unlock.veh) return "Bloqueado: Centro de Veículos.";
    return "";
  }

  function canStartBuild(type, x, y){
    const def=BuildingDefs[type];
    const t=tileAt(x,y);
    if(!t || t.water) return {ok:false, why:"Só em LAND."};
    if(t.build || t.buildingId) return {ok:false, why:"Tile ocupado."};
    if(t.enemy) return {ok:false, why:"Bloqueado por biomassa."};
    if(!withinBuildRange(x,y)) return {ok:false, why:`Fora do alcance (BR=${BR()}).`};
    if(gateReason(type)) return {ok:false, why:gateReason(type)};
    if(!def.place(t)) return {ok:false, why:"Local inválido (recurso ausente ou regra)."};
    if(!canAfford(def.cost)) return {ok:false, why:"Recursos insuficientes."};
    return {ok:true, why:""};
  }

  function placeBuilding(type, x, y){
    if(gameOver) return;
    const t=tileAt(x,y);
    const def=BuildingDefs[type];

    const check=canStartBuild(type,x,y);
    if(!check.ok){
      toast(check.why);
      return;
    }

    pay(def.cost);
    t.build = { type, tLeft:def.buildTime, tTotal:def.buildTime };
    toast(`Construção: ${def.name} (${def.buildTime}s).`);
    refreshUI();
  }

  function finishConstruction(tile){
    const type=tile.build.type;
    const id=nextId++;
    buildings.push({ id, type, x:tile.x, y:tile.y, vehProg:0, isoBuffer:0 });
    tile.buildingId=id;
    tile.build=null;

    if(type==="InfraCenter") unlock.infra=true;
    if(type==="MilitaryCenter") unlock.mil=true;
    if(type==="VehicleCenter") unlock.veh=true;

    toast(`${BuildingDefs[type].name} concluído.`);
    refreshUI();
  }

  function demolish(tile){
    if(gameOver) return;
    if(tile.build){
      tile.build=null;
      toast("Construção cancelada (sem reembolso).");
      return;
    }
    if(!tile.buildingId) return;
    const b=buildings.find(bb=>bb.id===tile.buildingId);
    if(!b || b.type==="HQ") return;

    const idx=buildings.findIndex(bb=>bb.id===b.id);
    if(idx>=0) buildings.splice(idx,1);
    tile.buildingId=0;

    unlock.infra = buildings.some(bb=>bb.type==="InfraCenter" && !tileAt(bb.x,bb.y).build);
    unlock.mil   = buildings.some(bb=>bb.type==="MilitaryCenter" && !tileAt(bb.x,bb.y).build);
    unlock.veh   = buildings.some(bb=>bb.type==="VehicleCenter" && !tileAt(bb.x,bb.y).build);

    toast("Edifício demolido (sem reembolso).");
    refreshUI();
  }

  // ============================================================
  // Economy + combat simulation
  // ============================================================
  function step(dt){
    if(gameOver) return;

    // Constructions advance with fE (rule)
    const fe0=fE();
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const t=grid[y][x];
        if(t.build){
          t.build.tLeft -= dt*fe0;
          if(t.build.tLeft<=0) finishConstruction(t);
        }
      }
    }

    // Enemy activation
    if(!enemyActive){
      enemyCountdown -= dt;
      if(enemyCountdown<=0){
        enemyActive=true;
        activeSeconds=0;
        toast("Biomassa ativa.");
      }
    } else {
      activeSeconds += dt;
    }

    const fe=fE();

    // Base rates (per spec)
    const oreRate = 5*(1+B_ext())*fe;          // /s
    const isoRate = (5/60)*(1+B_ext())*fe;     // /s
    const oreInExp = 10*(1+B_exp_through())*fe;
    const goldOutExp = 5*(1+B_exp_eff())*fe;
    const oreInRef = 10*fe;
    const supOutRef = 5*(1+B_sup_ref())*fe;

    const tVehicle = Math.max(7.5, 30*(1-B_veh_prod()));
    const oreCostVeh = 50*(1-B_veh_cost());
    const goldCostVeh = 25*(1-B_veh_cost());

    // Relays
    const relayBaseDmg=5;
    const relayR = 10*(1+B_relay_range());
    const relays = buildings.filter(b=>b.type==="Relay" && !tileAt(b.x,b.y).build);

    function enemyTilesInRadius(rx,ry,R){
      const r2=R*R;
      const minX=Math.floor(clamp(rx-R,0,N-1)), maxX=Math.floor(clamp(rx+R,0,N-1));
      const minY=Math.floor(clamp(ry-R,0,N-1)), maxY=Math.floor(clamp(ry+R,0,N-1));
      let count=0;
      for(let y=minY;y<=maxY;y++){
        for(let x=minX;x<=maxX;x++){
          if((x-rx)*(x-rx)+(y-ry)*(y-ry)<=r2 && grid[y][x].enemy) count++;
        }
      }
      return count;
    }

    // Buildings operate
    for(const b of buildings){
      const t=tileAt(b.x,b.y);
      if(t.build) continue;

      if(b.type==="HQ"){ t.player=true; continue; }
      if(t.enemy) continue;

      if(b.type==="OreExtractor"){
        if(t.ORE_rem>0){
          const out = Math.min(oreRate, t.ORE_rem/dt);
          t.ORE_rem = Math.max(0, t.ORE_rem - out*dt);
          state.ORE += out*dt;
        }
      }

      if(b.type==="IsoExtractor"){
        if(t.ISO_rem>0){
          const out = Math.min(isoRate, t.ISO_rem/dt);
          t.ISO_rem = Math.max(0, t.ISO_rem - out*dt);
          b.isoBuffer += out*dt;
          while(b.isoBuffer>=5){
            state.ISO += 5;
            b.isoBuffer -= 5;
          }
        }
      }

      if(b.type==="Export"){
        if(state.ORE>0){
          const ore_in = oreInExp;
          const ore_in_real = Math.min(ore_in, state.ORE/dt);
          const scale = ore_in>0 ? (ore_in_real/ore_in) : 0;
          state.ORE -= ore_in_real*dt;
          state.GOLD += (goldOutExp*scale)*dt;
        }
      }

      if(b.type==="Refinery"){
        if(state.ORE>0){
          const ore_in=oreInRef;
          const ore_in_real = Math.min(ore_in, state.ORE/dt);
          const scale = ore_in>0 ? (ore_in_real/ore_in) : 0;
          state.ORE -= ore_in_real*dt;
          state.SUP += (supOutRef*scale)*dt;
        }
      }

      if(b.type==="VehicleFactory"){
        b.vehProg += dt*fe;
        while(b.vehProg>=tVehicle){
          if(state.ORE>=oreCostVeh && state.GOLD>=goldCostVeh){
            state.ORE -= oreCostVeh;
            state.GOLD -= goldCostVeh;
            state.VEH += 1;
            b.vehProg -= tVehicle;
          } else {
            b.vehProg = tVehicle;
            break;
          }
        }
      }
    }

    // Relays: SUP consumption + damage
    for(const r of relays){
      const tilesIn = enemyTilesInRadius(r.x,r.y,relayR);
      const sup_need = (5/60) + (5/60)*(tilesIn/10);
      const needThisDt = sup_need*dt;
      const fS = needThisDt>0 ? Math.min(1, state.SUP/needThisDt) : 1;
      state.SUP = Math.max(0, state.SUP-needThisDt);

      const dmg = relayBaseDmg*(1+B_relay_dmg())*mV()*fe*fS;

      const r2=relayR*relayR;
      const minX=Math.floor(clamp(r.x-relayR,0,N-1)), maxX=Math.floor(clamp(r.x+relayR,0,N-1));
      const minY=Math.floor(clamp(r.y-relayR,0,N-1)), maxY=Math.floor(clamp(r.y+relayR,0,N-1));
      for(let y=minY;y<=maxY;y++){
        for(let x=minX;x<=maxX;x++){
          if((x-r.x)*(x-r.x)+(y-r.y)*(y-r.y)<=r2){
            const t=grid[y][x];
            if(t.enemy){
              const regen = 5/60;
              const L_time=Math.floor((activeSeconds/60)/2);
              const hpMax=25+5*L_time;
              t.hp = Math.min(hpMax, t.hp + regen*dt);
              t.hp -= dmg*dt;
              if(t.hp<=0){ t.enemy=false; t.hp=0; }
            }
          }
        }
      }
    }

    // Global regen (simple)
    if(enemyActive){
      const regen=5/60;
      const L_time=Math.floor((activeSeconds/60)/2);
      const hpMax=25+5*L_time;
      for(let y=0;y<N;y++){
        for(let x=0;x<N;x++){
          const t=grid[y][x];
          if(t.enemy) t.hp = Math.min(hpMax, t.hp + regen*dt);
        }
      }
    }

    // Spread (discrete attempts each 1s)
    spreadTick += dt;
    if(enemyActive && spreadTick>=1){
      while(spreadTick>=1){
        spreadOnce();
        spreadTick -= 1;
      }
    }

    // Consolidate each minute
    consolidateTick += dt;
    if(consolidateTick>=60){
      while(consolidateTick>=60){
        consolidateOnce();
        consolidateTick -= 60;
      }
    }

    // Clamp
    state.ORE=Math.max(0,state.ORE);
    state.GOLD=Math.max(0,state.GOLD);
    state.SUP=Math.max(0,state.SUP);

    checkWinLose();
    refreshUI();
  }

  function spreadOnce(){
    const minutesActive = activeSeconds/60;
    const pTime = diff.p0 + 0.05*Math.floor(minutesActive/2);

    const relayR = 10*(1+B_relay_range());
    const relays = buildings.filter(b=>b.type==="Relay" && !tileAt(b.x,b.y).build);
    const supFactor = 1 - B_relay_sup();

    function inRelay(x,y){
      for(const r of relays){
        if(dist(x,y,r.x,r.y) <= relayR) return true;
      }
      return false;
    }

    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    const infected=[];
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const t=grid[y][x];
        if(!t.enemy) continue;

        const inside=inRelay(x,y);
        const pFinal = Math.max(0.05, inside ? pTime*supFactor : pTime);

        const [dx,dy]=dirs[Math.floor(Math.random()*dirs.length)];
        const nx=x+dx, ny=y+dy;
        const n=tileAt(nx,ny);
        if(!n || !n.land) continue;
        if(n.enemy) continue;
        if(dist(nx,ny,HQ.x,HQ.y)<=2) continue;

        if(Math.random()<pFinal) infected.push(n);
      }
    }
    for(const t of infected) infectTile(t,false);
  }

  function consolidateOnce(){
    const chance=0.25;
    const br=BR();
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const t=grid[y][x];
        if(!t.land) continue;
        if(t.enemy){ t.player=false; continue; }
        if(dist(x,y,HQ.x,HQ.y)<=br){
          if(!t.player && Math.random()<chance) t.player=true;
        }
      }
    }
  }

  function checkWinLose(){
    let landTotal=0, enemyTiles=0, playerTiles=0;
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const t=grid[y][x];
        if(!t.land) continue;
        landTotal++;
        if(t.enemy) enemyTiles++;
        if(t.player) playerTiles++;
      }
    }
    const P_enemy = landTotal ? (100*enemyTiles/landTotal) : 0;
    const P_player = landTotal ? (100*playerTiles/landTotal) : 0;

    if(P_player >= diff.winP){
      gameOver=true;
      winLoseMsg=`✅ Vitória — ${fmt(P_player,1)}% controlado.`;
      toast(winLoseMsg);
    } else if(P_enemy >= diff.loseP){
      gameOver=true;
      winLoseMsg=`⛔ Derrota — biomassa em ${fmt(P_enemy,1)}%.`;
      toast(winLoseMsg);
    } else {
      winLoseMsg="—";
    }

    document.getElementById("pPlayer").textContent=fmt(P_player,1);
    document.getElementById("pEnemy").textContent=fmt(P_enemy,1);
    document.getElementById("barPlayer").style.width=`${clamp(P_player,0,100)}%`;
    document.getElementById("barEnemy").style.width=`${clamp(P_enemy,0,100)}%`;
    document.getElementById("winLose").textContent=winLoseMsg;
  }

  // ============================================================
  // UI: rates snapshot (stocks + deltas)
  // ============================================================
  function activeBuildings(){
    return buildings.filter(b => !tileAt(b.x,b.y).build && !tileAt(b.x,b.y).enemy);
  }

  function computeRatesSnapshot(dt=1){
    const fe=fE();
    const abs = activeBuildings();

    const Bext = B_ext();
    const BexpEff = B_exp_eff();
    const BexpThr = B_exp_through();
    const Bsup = B_sup_ref();

    const oreExtPer = 5*(1+Bext)*fe;
    const isoExtPer = (5/60)*(1+Bext)*fe;
    const oreInExp = 10*(1+BexpThr)*fe;
    const goldOutExp = 5*(1+BexpEff)*fe;
    const oreInRef = 10*fe;
    const supOutRef = 5*(1+Bsup)*fe;

    let dORE=0, dISO=0, dGOLD=0, dSUP=0;

    // extraction limited by deposit
    for(const b of abs){
      const t=tileAt(b.x,b.y);
      if(b.type==="OreExtractor" && t.ORE_rem>0){
        dORE += Math.min(oreExtPer, t.ORE_rem/dt);
      }
      if(b.type==="IsoExtractor" && t.ISO_rem>0){
        dISO += Math.min(isoExtPer, t.ISO_rem/dt);
      }
    }

    // export/refine share ORE stock
    const expCount = abs.filter(b=>b.type==="Export").length;
    const refCount = abs.filter(b=>b.type==="Refinery").length;

    const oreNeed = expCount*oreInExp + refCount*oreInRef;
    const oreAvailRate = state.ORE/dt;
    const oreScale = oreNeed>0 ? Math.min(1, oreAvailRate/oreNeed) : 1;

    dORE  -= oreNeed*oreScale;
    dGOLD += expCount*(goldOutExp*oreScale);
    dSUP  += refCount*(supOutRef*oreScale);

    // relay SUP consumption
    const relayR = 10*(1+B_relay_range());
    const relays = abs.filter(b=>b.type==="Relay");

    function enemyTilesInRadius(rx,ry,R){
      const r2=R*R;
      const minX=Math.floor(clamp(rx-R,0,N-1)), maxX=Math.floor(clamp(rx+R,0,N-1));
      const minY=Math.floor(clamp(ry-R,0,N-1)), maxY=Math.floor(clamp(ry+R,0,N-1));
      let count=0;
      for(let y=minY;y<=maxY;y++){
        for(let x=minX;x<=maxX;x++){
          if((x-rx)*(x-rx)+(y-ry)*(y-ry)<=r2 && grid[y][x].enemy) count++;
        }
      }
      return count;
    }
    let supNeed=0;
    for(const r of relays){
      const tilesIn = enemyTilesInRadius(r.x,r.y,relayR);
      supNeed += (5/60) + (5/60)*(tilesIn/10);
    }
    dSUP -= supNeed;

    return {dORE,dISO,dGOLD,dSUP, fe};
  }

  function fmtRatePerSec(v){
    const s=v>=0?"+":"";
    return `${s}${fmt(v,1)}/s`;
  }
  function fmtRatePerMin(vPerSec){
    const v=vPerSec*60;
    const s=v>=0?"+":"";
    return `${s}${fmt(v,0)}/min`;
  }

  // ============================================================
  // UI rendering: top chips + alerts
  // ============================================================
  const chipsEl=document.getElementById("chips");

  function chipHTML(icon, label, value, delta){
    return `
      <div class="chip">
        <div class="icon">${icon}</div>
        <div class="meta">
          <div class="k">${label}</div>
          <div class="v">${value}</div>
          <div class="d">${delta}</div>
        </div>
      </div>
    `;
  }

  function refreshTopbar(){
    const snap=computeRatesSnapshot(1);
    const et=energyTotals();
    const netE=Math.max(0, et.E_gen - et.E_use);
    const eTag = snap.fe < 0.999 ? `DÉFICE • fE ${fmt(snap.fe,2)}` : `OK • fE 1.00`;

    chipsEl.innerHTML =
      chipHTML(Icons.ore, "ORE", fmt(state.ORE,0), fmtRatePerSec(snap.dORE)) +
      chipHTML(Icons.iso, "ISO", fmt(state.ISO,0), fmtRatePerMin(snap.dISO)) +
      chipHTML(Icons.gold,"GOLD",fmt(state.GOLD,0),fmtRatePerSec(snap.dGOLD)) +
      chipHTML(Icons.sup, "SUP", fmt(state.SUP,0), fmtRatePerMin(snap.dSUP)) +
      chipHTML(Icons.energy,"Energia", fmt(netE,0), `${fmt(et.E_gen,0)} gen • ${fmt(et.E_use,0)} use • ${eTag}`) +
      chipHTML(Icons.veh, "VEH", fmt(state.VEH,0), `mV ${fmt(mV(),2)} ( +25% / 5 )`);
  }

  function computeAlerts(){
    const et=energyTotals();
    const fe=fE();
    const snap=computeRatesSnapshot(1);

    const msgs=[];
    if(fe<0.999) msgs.push(`Energia insuficiente: fE=${fmt(fe,2)} (produção/velocidade/poder reduzidos)`);
    if(state.ORE<20 && (snap.dORE<0)) msgs.push(`ORE baixo: export/refino limitados`);
    if(state.SUP<10 && snap.dSUP<0) msgs.push(`SUP baixo: relays podem perder eficiência`);
    if(enemyActive) msgs.push(`Biomassa ativa há ${fmt(activeSeconds/60,0)} min (p cresce +5% / 2min)`);
    if(gameOver) msgs.push(winLoseMsg);

    let pillClass="pill";
    let pillText="OK";
    if(gameOver){ pillClass="pill bad"; pillText="FIM"; }
    else if(msgs.some(m=>m.includes("insuficiente") || m.includes("baixo"))){ pillClass = fe<0.8 ? "pill bad" : "pill warn"; pillText="ATENÇÃO"; }
    else if(enemyActive){ pillClass="pill warn"; pillText="AMEAÇA"; }
    else { pillClass="pill good"; pillText="OK"; }

    return { text: msgs.join(" • ") || "—", pillClass, pillText };
  }

  function refreshAlerts(){
    const a=computeAlerts();
    document.getElementById("alertsText").textContent = a.text;
    const pill=document.getElementById("alertsPill");
    pill.className = a.pillClass;
    pill.textContent = a.pillText;
  }

  // ============================================================
  // Build menu UI (simplified + costs + locked reasons)
  // ============================================================
  const buildArea=document.getElementById("buildArea");

  const BuildGroups = [
    { title:"Energia", subtitle:"mantém fE=1.00", types:["SolarB","SolarA","Nuclear"] },
    { title:"Extração", subtitle:"depósitos finitos", types:["OreExtractor","IsoExtractor"] },
    { title:"Economia", subtitle:"ORE → GOLD / SUP", types:["Export","Refinery"] },
    { title:"Militar", subtitle:"defesa automática", types:["Relay"] },
    { title:"Indústria", subtitle:"VEH reforça relays", types:["VehicleFactory"] },
    { title:"Centros", subtitle:"desbloqueiam progressão", types:["InfraCenter","MilitaryCenter","VehicleCenter"] },
  ];

  function buildButtonLabel(type){
    const def=BuildingDefs[type];
    const gen=(typeof def.E_gen==="function")?def.E_gen():def.E_gen;
    const use=(typeof def.E_use==="function")?def.E_use():def.E_use;
    const lock = gateReason(type);

    // concise sub line: cost + time + energy delta
    const eLine = (gen||use) ? `E +${fmt(gen,0)} / -${fmt(use,0)}` : `E -${fmt(use,0)}`;
    const sub = `${costText(def.cost)} • ${def.buildTime}s • ${eLine}` + (lock ? ` • ${lock}` : "");

    return { name:def.name, sub };
  }

  function refreshBuildMenu(){
    let html="";
    for(const g of BuildGroups){
      html += `<div class="groupTitle"><b>${g.title}</b><span>${g.subtitle}</span></div>`;
      html += `<div class="gridBtns">`;
      for(const type of g.types){
        const def=BuildingDefs[type];
        const label=buildButtonLabel(type);
        const lock=gateReason(type);
        const disabled = !!lock || gameOver;

        html += `
          <button data-build="${type}" ${disabled ? "disabled":""} title="${label.sub.replaceAll('"','&quot;')}">
            <div class="bIcon">${def.icon}</div>
            <div class="bText">
              <div class="name">${label.name}</div>
              <div class="sub">${label.sub}</div>
            </div>
          </button>
        `;
      }
      html += `</div>`;
    }

    // selection + cancel
    html += `
      <div class="card" style="margin-top:12px">
        <div class="cardTop">
          <h3>Modo de construção</h3>
          <span class="badge">${buildMode ? "ATIVO" : "—"}</span>
        </div>
        <div class="hint">Atual: <b>${buildMode ? BuildingDefs[buildMode].name : "Nenhum"}</b></div>
        <div class="sep"></div>
        <button id="btnCancelBuild" style="width:100%;justify-content:center">Cancelar (Esc)</button>
      </div>
    `;
    buildArea.innerHTML = html;

    // hook events
    [...buildArea.querySelectorAll("button[data-build]")].forEach(btn=>{
      btn.onclick = () => {
        const type = btn.getAttribute("data-build");
        buildMode = type;
        highlightBuildSelection();
        toast(`Modo: ${BuildingDefs[type].name}. Clique num tile válido.`);
        refreshUI();
      };
    });
    const cancel=document.getElementById("btnCancelBuild");
    cancel.onclick = ()=>{
      buildMode=null;
      highlightBuildSelection();
      toast("Modo de construção cancelado.");
      refreshUI();
    };

    highlightBuildSelection();
  }

  function highlightBuildSelection(){
    [...buildArea.querySelectorAll("button[data-build]")].forEach(btn=>{
      btn.classList.toggle("selected", btn.getAttribute("data-build")===buildMode);
    });
  }

  // ============================================================
  // Selection info UI (tile + building breakdown + upgrades)
  // ============================================================
  const infoArea=document.getElementById("infoArea");

  function buildingOnTile(tile){
    if(!tile?.buildingId) return null;
    return buildings.find(b=>b.id===tile.buildingId) || null;
  }

  function effectiveBuildingStats(b){
    // Returns a coherent "Base -> Effective" summary for key buildings.
    const fe=fE();
    const t=tileAt(b.x,b.y);
    const def=BuildingDefs[b.type];

    const gen=(typeof def.E_gen==="function")?def.E_gen():def.E_gen;
    const use=(typeof def.E_use==="function")?def.E_use():def.E_use;

    const base = [];
    const eff = [];
    const mult = [];

    mult.push(`fE=${fmt(fe,2)}`);

    if(b.type==="OreExtractor"){
      const baseOut=5*(1+B_ext());
      const effOut = (t.ORE_rem>0) ? Math.min(baseOut*fe, t.ORE_rem) : 0;
      base.push(`ORE +${fmt(baseOut,1)}/s`);
      eff.push(`ORE +${fmt(effOut,1)}/s (depósito ${t.ORE_rem})`);
      mult.push(`B_ext=+${25*up.L_ext}%`);
    }

    if(b.type==="IsoExtractor"){
      const baseOut=(5/60)*(1+B_ext()); // /s
      const effOut=(t.ISO_rem>0)?Math.min(baseOut*fe, t.ISO_rem):0;
      base.push(`ISO +${fmt(baseOut*60,0)}/min`);
      eff.push(`ISO +${fmt(effOut*60,0)}/min (depósito ${t.ISO_rem})`);
      mult.push(`B_ext=+${25*up.L_ext}%`);
      mult.push(`UI em pacotes de 5 ISO`);
    }

    if(b.type==="Export"){
      const baseOreIn = 10*(1+B_exp_through());
      const baseGoldOut = 5*(1+B_exp_eff());
      const oreInEff = baseOreIn*fe;
      const scale = oreInEff>0 ? Math.min(1, (state.ORE/1)/oreInEff) : 0; // dt=1 snapshot
      base.push(`ORE -${fmt(baseOreIn,1)}/s`);
      base.push(`GOLD +${fmt(baseGoldOut,1)}/s`);
      eff.push(`ORE -${fmt(oreInEff*scale,1)}/s (limitado por stock)`);
      eff.push(`GOLD +${fmt((baseGoldOut*fe)*scale,1)}/s`);
      mult.push(`B_thr=+${25*up.L_exp_through}%`);
      mult.push(`B_eff=+${25*up.L_exp_eff}%`);
    }

    if(b.type==="Refinery"){
      const baseOreIn = 10;
      const baseSupOut = 5*(1+B_sup_ref());
      const oreInEff = baseOreIn*fe;
      const scale = oreInEff>0 ? Math.min(1, (state.ORE/1)/oreInEff) : 0;
      base.push(`ORE -${fmt(baseOreIn,1)}/s`);
      base.push(`SUP +${fmt(baseSupOut,1)}/s`);
      eff.push(`ORE -${fmt(oreInEff*scale,1)}/s (limitado por stock)`);
      eff.push(`SUP +${fmt((baseSupOut*fe)*scale,1)}/s`);
      mult.push(`B_sup=+${25*up.L_sup_ref}%`);
    }

    if(b.type==="VehicleFactory"){
      const tVehicle = Math.max(7.5, 30*(1-B_veh_prod()));
      const oreCostVeh = 50*(1-B_veh_cost());
      const goldCostVeh = 25*(1-B_veh_cost());
      base.push(`1 VEH / ${fmt(tVehicle,1)}s`);
      base.push(`Custo: ${fmt(oreCostVeh,0)} ORE • ${fmt(goldCostVeh,0)} GOLD`);
      eff.push(`Progresso: ${fmt(b.vehProg,1)}/${fmt(tVehicle,1)}s (fE aplicado)`);
      mult.push(`B_prod=+${25*up.L_veh_prod}% (tempo ↓)`);
      mult.push(`B_cost=+${25*up.L_veh_cost}% (custo ↓)`);
    }

    if(b.type==="Relay"){
      const R = 10*(1+B_relay_range());
      // compute a snapshot of SUP need and fS
      const tilesIn = (()=>{
        const r2=R*R;
        const minX=Math.floor(clamp(b.x-R,0,N-1)), maxX=Math.floor(clamp(b.x+R,0,N-1));
        const minY=Math.floor(clamp(b.y-R,0,N-1)), maxY=Math.floor(clamp(b.y+R,0,N-1));
        let c=0;
        for(let y=minY;y<=maxY;y++){
          for(let x=minX;x<=maxX;x++){
            if((x-b.x)*(x-b.x)+(y-b.y)*(y-b.y)<=r2 && grid[y][x].enemy) c++;
          }
        }
        return c;
      })();
      const sup_need = (5/60) + (5/60)*(tilesIn/10);
      const fS = sup_need>0 ? Math.min(1, state.SUP/(sup_need*1)) : 1; // dt=1 snapshot
      const dmg = 5*(1+B_relay_dmg())*mV()*fe*fS;

      base.push(`Raio: ${fmt(R,1)} tiles`);
      base.push(`Dano base: 5 DPS`);
      base.push(`SUP base: 5/min (+ ameaça)`);
      eff.push(`SUP need: ${fmt(sup_need*60,0)}/min (tiles inimigos: ${tilesIn})`);
      eff.push(`fS=${fmt(fS,2)} • DPS=${fmt(dmg,1)}`);
      mult.push(`B_dmg=+${25*up.L_relay_dmg}%`);
      mult.push(`B_range=+${25*up.L_relay_range}%`);
      mult.push(`mV=${fmt(mV(),2)} (VEH em blocos de 5)`);
    }

    return { gen,use, base, eff, mult };
  }

  function upgradeCardHTML(u){
    const lvl=up[u.key];
    const locked =
      (u.group==="infra" && !unlock.infra) ||
      (u.group==="mil" && !unlock.mil) ||
      (u.group==="veh" && !unlock.veh);

    const badge = locked ? `<span class="badge warn">BLOQUEADO</span>` : `<span class="badge">Nível ${lvl}/3</span>`;

    let btnHTML="";
    if(lvl>=3){
      btnHTML = `<button disabled style="width:100%;justify-content:center">Max</button>`;
    } else {
      const cost=u.costs[lvl];
      const disabled = locked || !canAfford(cost) || gameOver;
      const reason = locked
        ? (u.group==="infra" ? "Precisa Centro de Infraestrutura." : u.group==="mil" ? "Precisa Centro Militar." : "Precisa Centro de Veículos.")
        : (!canAfford(cost) ? "Recursos insuficientes." : "");
      btnHTML = `
        <button data-up="${u.key}" ${disabled?"disabled":""} style="width:100%;justify-content:center" title="${reason}">
          Comprar Nível ${lvl+1} • ${costText(cost)}
        </button>
      `;
    }

    return `
      <div class="card">
        <div class="cardTop">
          <h3>${u.name}</h3>
          ${badge}
        </div>
        <div class="hint">${u.desc()}</div>
        <div style="margin-top:10px">${btnHTML}</div>
      </div>
    `;
  }

  function refreshInfoPanel(){
    const t=tileAt(selected.x, selected.y);
    const b=buildingOnTile(t);

    let html="";

    // TILE CARD
    const tileBadge = t.water
      ? `<span class="badge">WATER</span>`
      : t.enemy ? `<span class="badge bad">BIOMASSA</span>`
      : t.player ? `<span class="badge good">PLAYER</span>`
      : `<span class="badge">NEUTRO</span>`;

    html += `
      <div class="card">
        <div class="cardTop">
          <h3>Tile (${t.x}, ${t.y})</h3>
          ${tileBadge}
        </div>
        <div class="kv"><span>Dentro do BR</span><b>${withinBuildRange(t.x,t.y) ? "Sim" : "Não"}</b></div>
        <div class="kv"><span>Distância HQ</span><b>${fmt(dist(t.x,t.y,HQ.x,HQ.y),1)}</b></div>
        <div class="kv"><span>ORE_rem</span><b>${t.ORE_rem}</b></div>
        <div class="kv"><span>ISO_rem</span><b>${t.ISO_rem}</b></div>
        ${t.enemy ? `<div class="kv"><span>HP biomassa</span><b>${fmt(t.hp,1)}</b></div>` : ``}
      </div>
    `;

    // BUILDING CARD
    if(t.build){
      const def=BuildingDefs[t.build.type];
      const p = 1 - (t.build.tLeft/t.build.tTotal);
      html += `
        <div class="card">
          <div class="cardTop">
            <h3>Em construção</h3>
            <span class="badge warn">${fmt(Math.max(0,t.build.tLeft),1)}s</span>
          </div>
          <div class="hint"><b>${def.name}</b><br/>${costText(def.cost)} • ${def.buildTime}s</div>
          <div class="bar" style="margin-top:10px"><div class="player" style="width:${clamp(p,0,1)*100}%"></div></div>
          <div class="mini" style="margin-top:8px">Velocidade afetada por energia: fE=${fmt(fE(),2)}</div>
        </div>
      `;
    } else if(b){
      const def=BuildingDefs[b.type];
      const st=effectiveBuildingStats(b);
      const eLine = `Energia: +${fmt(st.gen,0)} / -${fmt(st.use,0)}`;
      html += `
        <div class="card">
          <div class="cardTop">
            <h3>${def.name}</h3>
            <span class="badge">ATIVO</span>
          </div>
          <div class="kv"><span>${eLine}</span><b>${t.enemy ? "Neutralizado" : "Operacional"}</b></div>

          ${st.base.length ? `<div class="sep"></div>` : ``}

          ${st.base.length ? `<div class="hint"><b>Base</b><br/>${st.base.map(x=>`• ${x}`).join("<br/>")}</div>` : ``}
          ${st.eff.length ? `<div class="hint" style="margin-top:10px"><b>Efetivo</b><br/>${st.eff.map(x=>`• ${x}`).join("<br/>")}</div>` : ``}
          ${st.mult.length ? `<div class="mini" style="margin-top:10px"><b>Multiplicadores</b>: ${st.mult.join(" • ")}</div>` : ``}

          <div class="sep"></div>
          <button class="danger" data-demolish="1" style="width:100%;justify-content:center">Demolir (sem reembolso)</button>
        </div>
      `;
    } else {
      html += `
        <div class="card">
          <div class="cardTop">
            <h3>Edifício</h3>
            <span class="badge">—</span>
          </div>
          <div class="hint">
            Seleciona um tile e constrói. A progressão é desbloqueada pelos centros (Infra / Militar / Veículos).
          </div>
        </div>
      `;
    }

    // UPGRADES LIST (simple, readable)
    html += `
      <div class="card">
        <div class="cardTop">
          <h3>Upgrades</h3>
          <span class="badge">25% por nível</span>
        </div>
        <div class="mini">
          Infra: ${unlock.infra ? "✅" : "⛔"} • Militar: ${unlock.mil ? "✅" : "⛔"} • Veículos: ${unlock.veh ? "✅" : "⛔"}
        </div>
      </div>
    `;
    for(const u of UpgradeDefs){
      html += upgradeCardHTML(u);
    }

    infoArea.innerHTML = html;

    // hook demolish + upgrades
    const dBtn = infoArea.querySelector("button[data-demolish]");
    if(dBtn){
      dBtn.onclick = () => demolish(t);
    }
    [...infoArea.querySelectorAll("button[data-up]")].forEach(btn=>{
      btn.onclick = () => buyUpgrade(btn.getAttribute("data-up"));
    });
  }

  function buyUpgrade(key){
    if(gameOver) return;
    const u=UpgradeDefs.find(x=>x.key===key);
    if(!u) return;
    const lvl=up[u.key];
    if(lvl>=3) return;

    const locked =
      (u.group==="infra" && !unlock.infra) ||
      (u.group==="mil" && !unlock.mil) ||
      (u.group==="veh" && !unlock.veh);
    if(locked){
      toast("Upgrade bloqueado: falta centro desbloqueador.");
      return;
    }

    const cost=u.costs[lvl];
    if(!canAfford(cost)){
      toast("Recursos insuficientes.");
      return;
    }
    // cap production/cost upgrades implicit by lvl 0..3
    pay(cost);
    up[u.key]+=1;
    toast(`Upgrade: ${u.name} → Nível ${up[u.key]}/3`);
    refreshUI();
  }

  // ============================================================
  // Render
  // ============================================================
  function resize(){
    DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const wrap=document.querySelector(".canvasWrap");
    const r=wrap.getBoundingClientRect();
    W=Math.floor(r.width); H=Math.floor(r.height);
    canvas.width=W*DPR; canvas.height=H*DPR;
    canvas.style.width=W+"px"; canvas.style.height=H+"px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }

  function tileToScreen(x,y){
    const mapW = N*(TILE+TILE_GAP) - TILE_GAP;
    const mapH = N*(TILE+TILE_GAP) - TILE_GAP;
    const ox = Math.floor((W - mapW)/2);
    const oy = Math.floor((H - mapH)/2);
    return { sx: ox + x*(TILE+TILE_GAP), sy: oy + y*(TILE+TILE_GAP), ox, oy, mapW, mapH };
  }
  function screenToTile(px,py){
    const mapW = N*(TILE+TILE_GAP) - TILE_GAP;
    const mapH = N*(TILE+TILE_GAP) - TILE_GAP;
    const ox = Math.floor((W - mapW)/2);
    const oy = Math.floor((H - mapH)/2);
    const x = Math.floor((px - ox)/(TILE+TILE_GAP));
    const y = Math.floor((py - oy)/(TILE+TILE_GAP));
    if(x<0||y<0||x>=N||y>=N) return null;
    return {x,y};
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle="#05070d"; ctx.fillRect(0,0,W,H);

    const {ox,oy,mapW,mapH} = tileToScreen(0,0);

    // subtle frame
    ctx.save();
    ctx.strokeStyle="rgba(109,255,181,0.06)";
    ctx.lineWidth=2;
    ctx.strokeRect(ox-8, oy-8, mapW+16, mapH+16);
    ctx.restore();

    const br=BR();
    const fe=fE();
    const relayR = 10*(1+B_relay_range());
    const relays = buildings.filter(b=>b.type==="Relay" && !tileAt(b.x,b.y).build);

    // tiles
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const t=grid[y][x];
        const p=tileToScreen(x,y);
        const sx=p.sx, sy=p.sy;

        if(t.water){
          ctx.fillStyle="#05070d";
          ctx.fillRect(sx,sy,TILE,TILE);
          if((x+y)%7===0){
            ctx.fillStyle="rgba(137,194,255,0.04)";
            ctx.fillRect(sx+3,sy+3,3,3);
          }
          continue;
        }

        // land base
        const n=fbm(x*0.12,y*0.12,seed+101,3,2,0.5);
        const base=18+Math.floor(n*18);
        ctx.fillStyle=`rgb(${10+base},${18+base},${32+base})`;
        ctx.fillRect(sx,sy,TILE,TILE);

        // border
        ctx.strokeStyle="rgba(19,34,66,0.65)";
        ctx.lineWidth=1;
        ctx.strokeRect(sx+0.5,sy+0.5,TILE-1,TILE-1);

        // BR overlay
        if(dist(x,y,HQ.x,HQ.y)<=br){
          ctx.fillStyle="rgba(109,255,181,0.03)";
          ctx.fillRect(sx,sy,TILE,TILE);
        }

        // player overlay
        if(t.player){
          ctx.fillStyle="rgba(109,255,181,0.10)";
          ctx.fillRect(sx,sy,TILE,TILE);
        }

        // enemy overlay
        if(t.enemy){
          ctx.fillStyle="rgba(255,77,125,0.22)";
          ctx.fillRect(sx,sy,TILE,TILE);
          if((x*13+y*7)%5===0){
            ctx.fillStyle="rgba(255,77,125,0.55)";
            ctx.fillRect(sx+2,sy+2,2,2);
          }
        }

        // resources
        if(t.ORE_rem>0){
          ctx.fillStyle="rgba(199,176,138,0.9)";
          ctx.fillRect(sx+2,sy+TILE-4,3,2);
          ctx.fillStyle="rgba(199,176,138,0.35)";
          ctx.fillRect(sx+6,sy+TILE-4,2,2);
        }
        if(t.ISO_rem>0){
          ctx.fillStyle="rgba(137,194,255,0.95)";
          ctx.fillRect(sx+TILE-5,sy+2,3,3);
        }

        // construction
        if(t.build){
          const prog=1-(t.build.tLeft/t.build.tTotal);
          ctx.fillStyle="rgba(137,194,255,0.14)";
          ctx.fillRect(sx,sy,TILE,TILE);
          ctx.fillStyle="rgba(137,194,255,0.75)";
          ctx.fillRect(sx+1,sy+TILE-2, Math.max(0,(TILE-2)*prog), 1);
        }

        // building marker
        if(t.buildingId){
          const b=buildings.find(bb=>bb.id===t.buildingId);
          if(b){
            let col="rgba(207,232,255,0.75)";
            if(b.type==="Relay") col="rgba(255,109,138,0.85)";
            if(b.type==="Nuclear") col="rgba(109,255,251,0.85)";
            if(b.type==="SolarB"||b.type==="SolarA") col="rgba(109,255,181,0.85)";
            if(b.type.endsWith("Center")) col="rgba(137,194,255,0.85)";
            ctx.fillStyle=col;
            ctx.fillRect(sx+5,sy+5,TILE-10,TILE-10);

            if(b.type==="HQ"){
              ctx.strokeStyle="rgba(109,255,181,0.9)";
              ctx.lineWidth=2;
              ctx.strokeRect(sx+2,sy+2,TILE-4,TILE-4);
            }
          }
        }

        // selection highlight
        if(selected && selected.x===x && selected.y===y){
          ctx.strokeStyle="rgba(109,255,181,0.95)";
          ctx.lineWidth=2;
          ctx.strokeRect(sx+1,sy+1,TILE-2,TILE-2);
        }
      }
    }

    // relay range
    ctx.save();
    ctx.globalCompositeOperation="lighter";
    for(const r of relays){
      const p=tileToScreen(r.x,r.y);
      const cx=p.sx+TILE/2, cy=p.sy+TILE/2;
      const pxPerTile=(TILE+TILE_GAP);
      ctx.strokeStyle="rgba(255,109,138,0.10)";
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.arc(cx,cy, relayR*pxPerTile, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();

    // energy warning overlay
    if(fe<0.999){
      ctx.save();
      ctx.fillStyle="rgba(255,211,109,0.10)";
      ctx.fillRect(ox-8, oy-8, mapW+16, 26);
      ctx.fillStyle="rgba(255,211,109,0.9)";
      ctx.font="12px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText(`Energia insuficiente — fE=${fmt(fe,2)} (tudo reduzido)`, ox+8, oy+10);
      ctx.restore();
    }

    requestAnimationFrame(draw);
  }

  // ============================================================
  // Interaction
  // ============================================================
  function setSelected(x,y){ selected={x,y}; refreshInfoPanel(); }

  canvas.addEventListener("click",(e)=>{
    const r=canvas.getBoundingClientRect();
    const p=screenToTile(e.clientX-r.left, e.clientY-r.top);
    if(!p) return;
    setSelected(p.x,p.y);
    if(buildMode) placeBuilding(buildMode, p.x, p.y);
  });

  window.addEventListener("keydown",(e)=>{
    if(e.key==="Escape"){
      buildMode=null;
      highlightBuildSelection();
      toast("Modo de construção cancelado.");
      refreshUI();
    }
  });

  // Controls
  document.getElementById("btnPause").onclick=()=>{
    paused=!paused;
    document.getElementById("btnPause").textContent = paused ? "▶ Retomar" : "⏸ Pausa";
  };
  document.getElementById("btnSpeed").onclick=()=>{
    speed = speed===1 ? 2 : (speed===2 ? 4 : 1);
    document.getElementById("btnSpeed").textContent = `⏩ ${speed}x`;
  };
  document.getElementById("btnRestart").onclick=()=>{
    genMap();
    toast("Novo jogo.");
  };

  // ============================================================
  // Status UI
  // ============================================================
  function refreshStatus(){
    const {E_gen,E_use}=energyTotals();
    const fe = (E_use>0)?Math.min(1,E_gen/E_use):1;

    document.getElementById("eGen").textContent=fmt(E_gen,0);
    document.getElementById("eUse").textContent=fmt(E_use,0);
    document.getElementById("fE").textContent=fmt(fe,2);

    document.getElementById("diffName").textContent=diff.name;
    document.getElementById("activeMins").textContent=fmt(enemyActive?(activeSeconds/60):0,0);

    document.getElementById("supStock").textContent=fmt(state.SUP,0);
    document.getElementById("vehStock").textContent=fmt(state.VEH,0);
    document.getElementById("mV").textContent=fmt(mV(),2);

    const p = E_use>0 ? clamp(E_gen/E_use,0,1) : 1;
    document.getElementById("barEnergy").style.width = `${p*100}%`;
    const supP = clamp(state.SUP/200,0,1);
    document.getElementById("barSupply").style.width = `${supP*100}%`;

    document.getElementById("winGoal").textContent = diff.winP;
    document.getElementById("loseGoal").textContent = diff.loseP;
  }

  function refreshUI(){
    refreshTopbar();
    refreshAlerts();
    refreshBuildMenu();
    refreshInfoPanel();
    refreshStatus();
  }

  // ============================================================
  // Toast
  // ============================================================
  let toastTimer=null;
  function toast(msg){
    toastEl.textContent=msg;
    toastEl.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer=setTimeout(()=>toastEl.classList.remove("show"), 2400);
  }

  // ============================================================
  // Main loop
  // ============================================================
  let last=performance.now();
  function loop(now){
    const delta=(now-last)/1000;
    last=now;
    if(!paused){
      acc += delta*speed;
      const dt=dtBase;
      while(acc>=dt){
        step(dt);
        acc -= dt;
      }
    }
    requestAnimationFrame(loop);
  }

  // ============================================================
  // Boot
  // ============================================================
  function start(){
    resize();
    window.addEventListener("resize",resize);
    genMap();
    setSelected(HQ.x,HQ.y);
    toast("Dica: começa por Solar (B) para manter fE=1.00.");
    refreshUI();
    requestAnimationFrame(draw);
    requestAnimationFrame(loop);
  }
  start();
})();
</script>
</body>
</html>
